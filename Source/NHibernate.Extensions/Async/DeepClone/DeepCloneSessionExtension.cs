//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using NHibernate.Collection;
using NHibernate.Engine;
using NHibernate.Extensions.Internal;
using NHibernate.Persister.Entity;
using NHibernate.Proxy;
using NHibernate.Type;
using NHibernate.Util;

namespace NHibernate.Extensions
{
    using System.Threading.Tasks;
    using System.Threading;
    public static partial class DeepCloneSessionExtension
    {

        #region ISession DeepClone

        public static Task<IList<T>> DeepCloneAsync<T>(this ISession session, IEnumerable<T> entities, Func<DeepCloneOptions, DeepCloneOptions> optsFn = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled<IList<T>>(cancellationToken);
            }
            try
            {
                var opts = new DeepCloneOptions();
                if (optsFn != null)
                    opts = optsFn(opts);
                return DeepCloneAsync(session, entities, opts, cancellationToken);
            }
            catch (Exception ex)
            {
                return Task.FromException<IList<T>>(ex);
            }
        }

        public static async Task<IList<T>> DeepCloneAsync<T>(this ISession session, IEnumerable<T> entities, DeepCloneOptions opts, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            var resolvedEntities = new Dictionary<object, object>();
            var result = new List<T>();
            foreach (var entity in entities)
            {
                var clone = (T) await (DeepCloneAsync(session.GetSessionImplementation(), entity, opts, null, resolvedEntities, cancellationToken: cancellationToken)).ConfigureAwait(false);
                result.Add(clone);
            }

            return result;
        }

        public static Task<T> DeepCloneAsync<T>(this ISession session, T entity, Func<DeepCloneOptions, DeepCloneOptions> optsAction = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled<T>(cancellationToken);
            }
            try
            {
                var opts = new DeepCloneOptions();
                if (optsAction != null)
                    opts = optsAction(opts);
                return DeepCloneAsync(session, entity, opts, cancellationToken);
            }
            catch (Exception ex)
            {
                return Task.FromException<T>(ex);
            }
        }

        public static async Task<T> DeepCloneAsync<T>(this ISession session, T entity, DeepCloneOptions opts, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            return (T)await (DeepCloneAsync(session.GetSessionImplementation(), entity, opts, null, new Dictionary<object, object>(), cancellationToken: cancellationToken)).ConfigureAwait(false);
        }

        public static Task<object> DeepCloneAsync(this ISession session, object entity, System.Type entityType = null, Func<DeepCloneOptions, DeepCloneOptions> optsFn = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled<object>(cancellationToken);
            }
            try
            {
                var opts = new DeepCloneOptions();
                if (optsFn != null)
                    opts = optsFn(opts);
                return DeepCloneAsync(session, entity, entityType, opts, cancellationToken);
            }
            catch (Exception ex)
            {
                return Task.FromException<object>(ex);
            }
        }

        public static Task<object> DeepCloneAsync(this ISession session, object entity, System.Type entityType, DeepCloneOptions opts, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled<object>(cancellationToken);
            }
            try
            {
                return DeepCloneAsync(session.GetSessionImplementation(), entity, opts, entityType, new Dictionary<object, object>(), cancellationToken: cancellationToken);
            }
            catch (Exception ex)
            {
                return Task.FromException<object>(ex);
            }
        }

        public static Task<IEnumerable> DeepCloneAsync(this ISession session, IEnumerable entities, Func<DeepCloneOptions, DeepCloneOptions> optsFn = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled<IEnumerable>(cancellationToken);
            }
            try
            {
                var opts = new DeepCloneOptions();
                if (optsFn != null)
                    opts = optsFn(opts);
                return DeepCloneAsync(session, entities, opts, cancellationToken);
            }
            catch (Exception ex)
            {
                return Task.FromException<IEnumerable>(ex);
            }
        }

        public static async Task<IEnumerable> DeepCloneAsync(this ISession session, IEnumerable entities, DeepCloneOptions opts, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            var collection = (IEnumerable) CreateNewCollection(entities.GetType(), out var addMethod);
            var resolvedEntities = new Dictionary<object, object>();
            foreach (var entity in entities)
            {
                var item = await (DeepCloneAsync(session.GetSessionImplementation(), entity, opts, null, resolvedEntities, null, cancellationToken)).ConfigureAwait(false);
                addMethod.Invoke(collection, new[] {item});
            }
            return collection;
        }

        #endregion

        #region IStatelessSession DeepClone

        public static Task<IList<T>> DeepCloneAsync<T>(this IStatelessSession session, IEnumerable<T> entities, Func<DeepCloneOptions, DeepCloneOptions> optsFn = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled<IList<T>>(cancellationToken);
            }
            try
            {
                var opts = new DeepCloneOptions();
                if (optsFn != null)
                    opts = optsFn(opts);
                return DeepCloneAsync(session, entities, opts, cancellationToken);
            }
            catch (Exception ex)
            {
                return Task.FromException<IList<T>>(ex);
            }
        }

        public static async Task<IList<T>> DeepCloneAsync<T>(this IStatelessSession session, IEnumerable<T> entities, DeepCloneOptions opts, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            var resolvedEntities = new Dictionary<object, object>();
            var result = new List<T>();
            foreach (var entity in entities)
            {
                var clone = (T) await (DeepCloneAsync(session.GetSessionImplementation(), entity, opts, null, resolvedEntities, cancellationToken: cancellationToken)).ConfigureAwait(false);
                result.Add(clone);
            }

            return result;
        }

        public static Task<T> DeepCloneAsync<T>(this IStatelessSession session, T entity, Func<DeepCloneOptions, DeepCloneOptions> optsFn = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled<T>(cancellationToken);
            }
            try
            {
                var opts = new DeepCloneOptions();
                if (optsFn != null)
                    opts = optsFn(opts);
                return DeepCloneAsync(session, entity, opts, cancellationToken);
            }
            catch (Exception ex)
            {
                return Task.FromException<T>(ex);
            }
        }

        public static async Task<T> DeepCloneAsync<T>(this IStatelessSession session, T entity, DeepCloneOptions opts, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            return (T)await (DeepCloneAsync(session.GetSessionImplementation(), entity, opts, null, new Dictionary<object, object>(), null, cancellationToken)).ConfigureAwait(false);
        }

        public static Task<object> DeepCloneAsync(this IStatelessSession session, object entity, System.Type entityType = null, Func<DeepCloneOptions, DeepCloneOptions> optsFn = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled<object>(cancellationToken);
            }
            try
            {
                var opts = new DeepCloneOptions();
                if (optsFn != null)
                    opts = optsFn(opts);
                return DeepCloneAsync(session, entity, entityType, opts, cancellationToken);
            }
            catch (Exception ex)
            {
                return Task.FromException<object>(ex);
            }
        }

        public static Task<object> DeepCloneAsync(this IStatelessSession session, object entity, System.Type entityType, DeepCloneOptions opts, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled<object>(cancellationToken);
            }
            try
            {
                return DeepCloneAsync(session.GetSessionImplementation(), entity, opts, entityType, new Dictionary<object, object>(), cancellationToken: cancellationToken);
            }
            catch (Exception ex)
            {
                return Task.FromException<object>(ex);
            }
        }

        public static Task<IEnumerable> DeepCloneAsync(this IStatelessSession session, IEnumerable entities, Func<DeepCloneOptions, DeepCloneOptions> optsFn = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled<IEnumerable>(cancellationToken);
            }
            try
            {
                var opts = new DeepCloneOptions();
                if (optsFn != null)
                    opts = optsFn(opts);
                return DeepCloneAsync(session, entities, opts, cancellationToken);
            }
            catch (Exception ex)
            {
                return Task.FromException<IEnumerable>(ex);
            }
        }

        public static async Task<IEnumerable> DeepCloneAsync(this IStatelessSession session, IEnumerable entities, DeepCloneOptions opts, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            var collection = (IEnumerable) CreateNewCollection(entities.GetType(), out var addMethod);
            var resolvedEntities = new Dictionary<object, object>();
            foreach (var entity in entities)
            {
                var item = await (DeepCloneAsync(session.GetSessionImplementation(), entity, opts, null, resolvedEntities, null, cancellationToken)).ConfigureAwait(false);
                addMethod.Invoke(collection, new[] {item});
            }
            return collection;
        }

        #endregion

        private static async Task<object> DeepCloneAsync(this ISessionImplementor session, object entity, DeepCloneOptions opts, System.Type entityType,
            IDictionary<object, object> resolvedEntities, DeepCloneParentEntity parentEntity = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            opts = opts ?? new DeepCloneOptions();
            if (entity == null || !NHibernateUtil.IsInitialized(entity))
                return entityType.GetDefaultValue();
            entityType = entityType ?? entity.GetUnproxiedType(true);

            if (entityType.IsSimpleType())
                return entity;

            AbstractEntityPersister entityMetadata;
            try
            {
                entityMetadata = (AbstractEntityPersister)session.Factory.GetClassMetadata(entityType);
            }
            catch (Exception)
            {
                return entityType.GetDefaultValue();
            }

            if (resolvedEntities.ContainsKey(entity) && parentEntity != null)
                return CopyOnlyForeignKeyProperties(resolvedEntities[entity], entityType, entityMetadata, opts, parentEntity);

            if (resolvedEntities.ContainsKey(entity))
                return resolvedEntities[entity];

            if (opts.CanCloneAsReferenceFunc != null && opts.CanCloneAsReferenceFunc(entityType))
                return entity;

            var propertyInfos = entityType.GetProperties();
            var copiedEntity = ReflectHelper.GetDefaultConstructor(entityType).Invoke(new object[0]);
            resolvedEntities.Add(entity, copiedEntity);

            foreach (var propertyInfo in propertyInfos
                .Where(p => opts.CanCloneIdentifier(entityType) || entityMetadata.IdentifierPropertyName != p.Name)
                .Where(p => !opts.GetIgnoreMembers(entityType).Contains(p.Name))
                .Where(p => p.GetSetMethod(true) != null))
            {
                IType propertyType;
                try
                {
                    propertyType = entityMetadata.GetPropertyType(propertyInfo.Name);
                }
                catch (Exception)
                {
                    continue;
                }

                var resolveFn = opts.GetResolveFunction(entityType, propertyInfo.Name);
                if (resolveFn != null)
                {
                    propertyInfo.SetValue(copiedEntity, resolveFn(entity), null);
                    continue;
                }

                if (propertyType.IsEntityType && opts.SkipEntityTypesValue.HasValue && opts.SkipEntityTypesValue.Value)
                    continue;

                //TODO: verify: false only when entity is a proxy or lazy field/property that is not yet initialized
                if (!NHibernateUtil.IsPropertyInitialized(entity, propertyInfo.Name))
                    continue;

                var propertyValue = propertyInfo.GetValue(entity, null);
                if (!NHibernateUtil.IsInitialized(propertyValue))
                {
                    //Use session load for proxy, works only for references (collections are not supported) 
                    if (
                        propertyValue != null &&
                        propertyValue.IsProxy() &&
                        !(propertyValue is IPersistentCollection) &&
                        opts.UseSessionLoadFunction
                        )
                    {
                        var lazyInit = ((INHibernateProxy)propertyValue).HibernateLazyInitializer;
                        propertyInfo.SetValue(copiedEntity, await (LoadEntityAsync(session, lazyInit.PersistentClass, lazyInit.Identifier, cancellationToken)).ConfigureAwait(false), null);
                    }
                    continue;
                }

                var filterFn = opts.GetFilterFunction(entityType, propertyInfo.Name);
                if (filterFn != null)
                    propertyValue = filterFn(propertyValue);

                var colNames = entityMetadata.GetPropertyColumnNames(propertyInfo.Name);
                var propType = propertyInfo.PropertyType;
                var cloneAsReference = opts.CanCloneAsReference(entityType, propertyInfo.Name);
                if (propertyType.IsCollectionType)
                {
                    var newCollection = CreateNewCollection(propertyType, out var addMethod);
                    propertyInfo.SetValue(copiedEntity, newCollection, null);
                    var colParentEntity = new DeepCloneParentEntity(copiedEntity, entityMetadata, propertyType, ((CollectionType)propertyType).GetReferencedColumns(session.Factory));
                    await (CloneCollectionAsync(session, opts, colParentEntity, resolvedEntities, newCollection, propertyValue, addMethod, cloneAsReference, cancellationToken)).ConfigureAwait(false);
                }
                else if (propertyType.IsEntityType)
                {
                    if (cloneAsReference)
                        propertyInfo.SetValue(copiedEntity, propertyValue, null);
                    //Check if we have a parent entity and that is bidirectional related to the current property (one-to-many)
                    else if (parentEntity != null && parentEntity.ReferencedColumns.SequenceEqual(colNames))
                        propertyInfo.SetValue(copiedEntity, parentEntity.Entity, null);
                    else
                        propertyInfo.SetValue(copiedEntity, await (session.DeepCloneAsync(propertyValue, opts, propType, resolvedEntities, cancellationToken: cancellationToken)).ConfigureAwait(false), null);
                }
                else if (propType.IsSimpleType())
                {
                    //Check if we have a parent entity and that is bidirectional related to the current property (one-to-many)
                    //we dont want to set FKs to the parent entity as the parent is cloned
                    if (parentEntity != null && parentEntity.ReferencedColumns.Contains(colNames.First()))
                        continue;
                    propertyInfo.SetValue(copiedEntity, propertyValue, null);
                }
            }
            return copiedEntity;
        }

        private static Task<object> LoadEntityAsync(ISessionImplementor sessionImpl, System.Type type, object identifier, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled<object>(cancellationToken);
            }
            try
            {
                if (sessionImpl is IStatelessSession statelessSession)
                {
                    return statelessSession.GetAsync(sessionImpl.Factory.TryGetGuessEntityName(type), identifier, cancellationToken);
                }

                return sessionImpl is ISession session ? session.LoadAsync(type, identifier, cancellationToken) : Task.FromResult<object>(null);
            }
            catch (Exception ex)
            {
                return Task.FromException<object>(ex);
            }
        }

        private static async Task CloneCollectionAsync(
            ISessionImplementor session,
            DeepCloneOptions opts,
            DeepCloneParentEntity parentEntity,
            IDictionary<object, object> resolvedEntities,
            object newCollection,
            object collection,
            MethodInfo addMethod,
            bool cloneAsReference, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            var enumerable = collection as IEnumerable;
            if (enumerable != null)
            {
                var enumerableType = enumerable.GetType();
                if (enumerableType.IsAssignableToGenericType(typeof(IDictionary<,>)))
                {
                    foreach (dynamic pair in enumerable)
                    {
                        var clone = cloneAsReference
                            ? (object)pair.Value
                            : await (session.DeepCloneAsync((object)pair.Value, opts, null, resolvedEntities, parentEntity, cancellationToken)).ConfigureAwait(false);
                        addMethod.Invoke(newCollection, new[] {pair.Key, clone});
                    }
                }
                else
                {
                    foreach (var item in enumerable)
                    {
                        var clone = cloneAsReference
                            ? item
                            : await (session.DeepCloneAsync(item, opts, null, resolvedEntities, parentEntity, cancellationToken)).ConfigureAwait(false);
                        addMethod.Invoke(newCollection, new[] {clone});
                    }
                }
            }
        }
    }
}
