//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.CodeDom;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;

namespace NHibernate.Extensions
{
    using System.Threading.Tasks;
    using System.Threading;
    public static partial class BatchFetchExtension
    {

        /// <summary>
        /// Batch fetching a collecion of keys by using ISession Linq provider
        /// </summary>
        /// <typeparam name="TEntity"></typeparam>
        /// <typeparam name="TProperty"></typeparam>
        /// <param name="session">NHibernate session</param>
        /// <param name="keys">Collection of keys that will be retrieved from the database</param>
        /// <param name="propertyExpr">Expression pointing to the property that represents the key</param>
        /// <param name="batchSize">Number of records that will be retrieved within one execution</param>
        /// <param name="queryFunc">Function to modify the query prior execution</param>
        /// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
        /// <returns>The fetched entites.</returns>
        public static Task<List<TEntity>> BatchFetchAsync<TEntity, TProperty>(this ISession session, ICollection<TProperty> keys,
            Expression<Func<TEntity, TProperty>> propertyExpr,
            int batchSize,
            Func<IQueryable<TEntity>, IQueryable<TEntity>> queryFunc = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (propertyExpr == null)
            {
                throw new ArgumentNullException(nameof(propertyExpr));
            }

            if (keys == null)
            {
                throw new ArgumentNullException(nameof(keys));
            }
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled<List<TEntity>>(cancellationToken);
            }
            try
            {

                return session.BatchFetch<TEntity>(batchSize)
                    .SetKeys(keys, propertyExpr)
                    .BeforeQueryExecution(queryFunc)
                    .ExecuteAsync(cancellationToken);
            }
            catch (Exception ex)
            {
                return Task.FromException<List<TEntity>>(ex);
            }
        }
    }
}
