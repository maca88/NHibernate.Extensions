//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using NHibernate.Collection;
using NHibernate.Engine;
using NHibernate.Extensions.Internal;
using NHibernate.Persister.Entity;
using NHibernate.Proxy;
using NHibernate.Type;
using NHibernate.Util;

namespace NHibernate.Extensions
{
    using System.Threading.Tasks;
    using System.Threading;
    public static partial class DeepCloneSessionExtension
    {

        #region ISession DeepClone

        public static Task<IList<T>> DeepCloneAsync<T>(this ISession session, IEnumerable<T> entities, Func<DeepCloneOptions, DeepCloneOptions> optsFn = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled<IList<T>>(cancellationToken);
            }
            try
            {
                var opts = new DeepCloneOptions();
                if (optsFn != null)
                    opts = optsFn(opts);
                return DeepCloneAsync(session, entities, opts, cancellationToken);
            }
            catch (Exception ex)
            {
                return Task.FromException<IList<T>>(ex);
            }
        }

        public static async Task<IList<T>> DeepCloneAsync<T>(this ISession session, IEnumerable<T> entities, DeepCloneOptions opts, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            var resolvedEntities = new Dictionary<object, object>();
            var result = new List<T>();
            foreach (var entity in entities)
            {
                var clone = (T) await (DeepCloneAsync(session.GetSessionImplementation(), entity, opts, null, resolvedEntities, cancellationToken: cancellationToken)).ConfigureAwait(false);
                result.Add(clone);
            }

            return result;
        }

        public static Task<T> DeepCloneAsync<T>(this ISession session, T entity, Func<DeepCloneOptions, DeepCloneOptions> optsAction = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled<T>(cancellationToken);
            }
            try
            {
                var opts = new DeepCloneOptions();
                if (optsAction != null)
                    opts = optsAction(opts);
                return DeepCloneAsync(session, entity, opts, cancellationToken);
            }
            catch (Exception ex)
            {
                return Task.FromException<T>(ex);
            }
        }

        public static async Task<T> DeepCloneAsync<T>(this ISession session, T entity, DeepCloneOptions opts, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            return (T)await (DeepCloneAsync(session.GetSessionImplementation(), entity, opts, null, new Dictionary<object, object>(), cancellationToken: cancellationToken)).ConfigureAwait(false);
        }

        public static Task<object> DeepCloneAsync(this ISession session, object entity, System.Type entityType = null, Func<DeepCloneOptions, DeepCloneOptions> optsFn = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled<object>(cancellationToken);
            }
            try
            {
                var opts = new DeepCloneOptions();
                if (optsFn != null)
                    opts = optsFn(opts);
                return DeepCloneAsync(session, entity, entityType, opts, cancellationToken);
            }
            catch (Exception ex)
            {
                return Task.FromException<object>(ex);
            }
        }

        public static Task<object> DeepCloneAsync(this ISession session, object entity, System.Type entityType, DeepCloneOptions opts, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled<object>(cancellationToken);
            }
            try
            {
                return DeepCloneAsync(session.GetSessionImplementation(), entity, opts, entityType, new Dictionary<object, object>(), cancellationToken: cancellationToken);
            }
            catch (Exception ex)
            {
                return Task.FromException<object>(ex);
            }
        }

        public static Task<IEnumerable> DeepCloneAsync(this ISession session, IEnumerable entities, Func<DeepCloneOptions, DeepCloneOptions> optsFn = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled<IEnumerable>(cancellationToken);
            }
            try
            {
                var opts = new DeepCloneOptions();
                if (optsFn != null)
                    opts = optsFn(opts);
                return DeepCloneAsync(session, entities, opts, cancellationToken);
            }
            catch (Exception ex)
            {
                return Task.FromException<IEnumerable>(ex);
            }
        }

        public static async Task<IEnumerable> DeepCloneAsync(this ISession session, IEnumerable entities, DeepCloneOptions opts, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            var collection = (dynamic) CreateNewCollection(entities.GetType());
            var resolvedEntities = new Dictionary<object, object>();
            foreach (var entity in entities)
            {
                var item = await (DeepCloneAsync(session.GetSessionImplementation(), entity, opts, null, resolvedEntities, null, cancellationToken)).ConfigureAwait(false);
                collection.Add((dynamic) item);
            }

            return collection;
        }

        #endregion

        #region IStatelessSession DeepClone

        public static Task<IList<T>> DeepCloneAsync<T>(this IStatelessSession session, IEnumerable<T> entities, Func<DeepCloneOptions, DeepCloneOptions> optsFn = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled<IList<T>>(cancellationToken);
            }
            try
            {
                var opts = new DeepCloneOptions();
                if (optsFn != null)
                    opts = optsFn(opts);
                return DeepCloneAsync(session, entities, opts, cancellationToken);
            }
            catch (Exception ex)
            {
                return Task.FromException<IList<T>>(ex);
            }
        }

        public static async Task<IList<T>> DeepCloneAsync<T>(this IStatelessSession session, IEnumerable<T> entities, DeepCloneOptions opts, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            var resolvedEntities = new Dictionary<object, object>();
            var result = new List<T>();
            foreach (var entity in entities)
            {
                var clone = (T) await (DeepCloneAsync(session.GetSessionImplementation(), entity, opts, null, resolvedEntities, cancellationToken: cancellationToken)).ConfigureAwait(false);
                result.Add(clone);
            }

            return result;
        }

        public static Task<T> DeepCloneAsync<T>(this IStatelessSession session, T entity, Func<DeepCloneOptions, DeepCloneOptions> optsFn = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled<T>(cancellationToken);
            }
            try
            {
                var opts = new DeepCloneOptions();
                if (optsFn != null)
                    opts = optsFn(opts);
                return DeepCloneAsync(session, entity, opts, cancellationToken);
            }
            catch (Exception ex)
            {
                return Task.FromException<T>(ex);
            }
        }

        public static async Task<T> DeepCloneAsync<T>(this IStatelessSession session, T entity, DeepCloneOptions opts, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            return (T)await (DeepCloneAsync(session.GetSessionImplementation(), entity, opts, null, new Dictionary<object, object>(), null, cancellationToken)).ConfigureAwait(false);
        }

        public static Task<object> DeepCloneAsync(this IStatelessSession session, object entity, System.Type entityType = null, Func<DeepCloneOptions, DeepCloneOptions> optsFn = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled<object>(cancellationToken);
            }
            try
            {
                var opts = new DeepCloneOptions();
                if (optsFn != null)
                    opts = optsFn(opts);
                return DeepCloneAsync(session, entity, entityType, opts, cancellationToken);
            }
            catch (Exception ex)
            {
                return Task.FromException<object>(ex);
            }
        }

        public static Task<object> DeepCloneAsync(this IStatelessSession session, object entity, System.Type entityType, DeepCloneOptions opts, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled<object>(cancellationToken);
            }
            try
            {
                return DeepCloneAsync(session.GetSessionImplementation(), entity, opts, entityType, new Dictionary<object, object>(), cancellationToken: cancellationToken);
            }
            catch (Exception ex)
            {
                return Task.FromException<object>(ex);
            }
        }

        public static Task<IEnumerable> DeepCloneAsync(this IStatelessSession session, IEnumerable entities, Func<DeepCloneOptions, DeepCloneOptions> optsFn = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled<IEnumerable>(cancellationToken);
            }
            try
            {
                var opts = new DeepCloneOptions();
                if (optsFn != null)
                    opts = optsFn(opts);
                return DeepCloneAsync(session, entities, opts, cancellationToken);
            }
            catch (Exception ex)
            {
                return Task.FromException<IEnumerable>(ex);
            }
        }

        public static async Task<IEnumerable> DeepCloneAsync(this IStatelessSession session, IEnumerable entities, DeepCloneOptions opts, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            var collection = (dynamic) CreateNewCollection(entities.GetType());
            var resolvedEntities = new Dictionary<object, object>();
            foreach (var entity in entities)
            {
                var item = await (DeepCloneAsync(session.GetSessionImplementation(), entity, opts, null, resolvedEntities, null, cancellationToken)).ConfigureAwait(false);
                collection.Add((dynamic) item);
            }

            return collection;
        }

        #endregion

        private static async Task<object> DeepCloneAsync(this ISessionImplementor session, object entity, DeepCloneOptions opts, System.Type entityType,
            IDictionary<object, object> resolvedEntities, DeepCloneParentEntity parentEntity = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            opts = opts ?? new DeepCloneOptions();
            if (entity == null || !NHibernateUtil.IsInitialized(entity))
            {
                return entityType?.GetDefaultValue();
            }

            entityType = entityType ?? entity.GetUnproxiedType(true);
            if (entityType.IsSimpleType())
            {
                return entity;
            }

            if (!(session.Factory.GetClassMetadata(entityType) is AbstractEntityPersister entityPersister))
            {
                return entityType.GetDefaultValue();
            }

            if (resolvedEntities.ContainsKey(entity))
            {
                return parentEntity != null
                    ? CopyOnlyForeignKeyProperties(resolvedEntities[entity], entityType, entityPersister, opts, parentEntity)
                    : resolvedEntities[entity];
            }

            var entityResolver = opts.EntityResolvers.FirstOrDefault(o => o.CanResolve(entityType, entity));
            if (entityResolver != null)
            {
                return entityResolver.Resolve(entity, entityPersister);
            }

            if (opts.CanCloneAsReferenceFunc != null && opts.CanCloneAsReferenceFunc(entityType))
            {
                return entity;
            }

            var id = opts.CanCloneIdentifier(entityType)
                ? await (CloneIdentifierAsync(session, entityPersister, entity, opts, resolvedEntities, cancellationToken)).ConfigureAwait(false)
                : GetDefaultIdentifier(entityPersister);
            var clone = entityPersister.Instantiate(id);
            resolvedEntities.Add(entity, clone);

            var propertyNames = entityPersister.PropertyNames;
            await (DeepClonePropertiesAsync(
                session,
                entity,
                clone,
                opts,
                entityType,
                resolvedEntities,
                parentEntity,
                propertyNames,
                entityPersister.PropertyTypes,
                entityPersister.PropertyLaziness,
                entityPersister.GetPropertyColumnNames,
                entityPersister.GetPropertyValue,
                entityPersister.SetPropertyValue
, cancellationToken            )).ConfigureAwait(false);

            return clone;
        }

        private static async Task DeepClonePropertiesAsync(
            ISessionImplementor session,
            object entity,
            object clone,
            DeepCloneOptions opts,
            System.Type entityType,
            IDictionary<object, object> resolvedEntities,
            DeepCloneParentEntity parentEntity,
            string[] propertyNames,
            IType[] propertyTypes,
            bool[] propertyLaziness,
            Func<int, string[]> getPropertyColumnNames,
            Func<object, int, object> getPropertyValueFunc,
            Action<object, int, object> setPropertyValueFunc
, CancellationToken cancellationToken = default(CancellationToken)            )
        {
            cancellationToken.ThrowIfCancellationRequested();
            for (var i = 0; i < propertyNames.Length; i++)
            {
                var propertyName = propertyNames[i];
                if (opts.GetIgnoreMembers(entityType).Contains(propertyName))
                {
                    continue;
                }

                var propertyType = propertyTypes[i];
                var resolveFn = opts.GetResolveFunction(entityType, propertyName);
                if (resolveFn != null)
                {
                    setPropertyValueFunc(clone, i, resolveFn(entity));
                    continue;
                }

                if (propertyType.IsEntityType && opts.SkipEntityTypesValue == true)
                {
                    continue;
                }

                var isLazy = propertyLaziness != null && propertyLaziness[i];
                if (isLazy && !NHibernateUtil.IsPropertyInitialized(entity, propertyName))
                {
                    continue;
                }

                var propertyValue = getPropertyValueFunc(entity, i);
                if (!NHibernateUtil.IsInitialized(propertyValue))
                {
                    // Use session load for proxy, works only for references (collections are not supported) 
                    if (
                        propertyValue != null &&
                        propertyValue.IsProxy() &&
                        !(propertyValue is IPersistentCollection) &&
                        opts.UseSessionLoadFunction
                    )
                    {
                        var lazyInit = ((INHibernateProxy) propertyValue).HibernateLazyInitializer;
                        setPropertyValueFunc(clone, i,
                            await (LoadEntityAsync(session, lazyInit.PersistentClass, lazyInit.Identifier, cancellationToken)).ConfigureAwait(false));
                    }

                    continue;
                }

                var filterFn = opts.GetFilterFunction(entityType, propertyName);
                if (filterFn != null)
                {
                    propertyValue = filterFn(propertyValue);
                }

                var colNames = getPropertyColumnNames(i);
                var cloneAsReference = opts.CanCloneAsReference(entityType, propertyName);
                if (propertyType is ComponentType componentType)
                {
                    setPropertyValueFunc(clone, i, await (CloneComponentAsync(session, componentType, propertyValue, clone, getPropertyColumnNames(i), opts, resolvedEntities, cancellationToken)).ConfigureAwait(false));
                }
                else if (propertyType.IsCollectionType)
                {
                    var newCollection = CreateNewCollection(propertyType);
                    setPropertyValueFunc(clone, i, newCollection);
                    var colParentEntity = new DeepCloneParentEntity(clone, propertyType, ((CollectionType) propertyType).GetReferencedColumns(session.Factory));
                    await (CloneCollectionAsync(session, opts, colParentEntity, resolvedEntities, newCollection, propertyValue, cloneAsReference, cancellationToken)).ConfigureAwait(false);
                }
                else if (propertyType.IsEntityType)
                {
                    object value;
                    if (cloneAsReference)
                    {
                        value = propertyValue;
                    }
                    // Check if we have a parent entity and that is bidirectional related to the current property (one-to-many)
                    else if (parentEntity != null && parentEntity.ReferencedColumns.SequenceEqual(colNames))
                    {
                        value = parentEntity.Entity;
                    }
                    else
                    {
                        value = await (session.DeepCloneAsync(propertyValue, opts, propertyType.ReturnedClass, resolvedEntities, cancellationToken: cancellationToken)).ConfigureAwait(false);
                    }

                    setPropertyValueFunc(clone, i, value);
                }
                else
                {
                    // Check if we have a parent entity and that is bidirectional related to the current property (one-to-many)
                    // we dont want to set FKs to the parent entity as the parent is cloned
                    if (parentEntity != null && parentEntity.ReferencedColumns.Contains(colNames.First()))
                    {
                        continue;
                    }

                    setPropertyValueFunc(clone, i, propertyType.DeepCopy(propertyValue, session.Factory));
                }
            }
        }

        private static Task<object> CloneIdentifierAsync(ISessionImplementor session, AbstractEntityPersister entityPersister, object entity, DeepCloneOptions opts, IDictionary<object, object> resolvedEntities, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled<object>(cancellationToken);
            }
            try
            {
                var id = entityPersister.GetIdentifier(entity);
                if (entityPersister.IdentifierType is ComponentType componentType)
                {
                    return CloneComponentAsync(session, componentType, id, null, entityPersister.IdentifierColumnNames, opts, resolvedEntities, cancellationToken);
                }
                else
                {
                    return Task.FromResult<object>(entityPersister.IdentifierType.DeepCopy(id, session.Factory));
                }
            }
            catch (Exception ex)
            {
                return Task.FromException<object>(ex);
            }
        }

        private static async Task<object> CloneComponentAsync(
            ISessionImplementor session,
            ComponentType componentType,
            object value,
            object parent,
            string[] columnNames,
            DeepCloneOptions opts,
            IDictionary<object, object> resolvedEntities, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            var names = componentType.PropertyNames;
            var clone = componentType.Instantiate(parent, session);

            await (DeepClonePropertiesAsync(
                session,
                value,
                clone,
                opts,
                componentType.ReturnedClass,
                resolvedEntities,
                null,
                componentType.PropertyNames,
                componentType.Subtypes,
                null,
                i => GetComponentPropertyColumnNames(session.Factory, componentType, i, columnNames),
                componentType.GetPropertyValue,
                (target, i, targetValue) =>
                {
                    var values = componentType.GetPropertyValues(target);
                    values[i] = targetValue;
                    componentType.SetPropertyValues(clone, values);
                }
, cancellationToken            )).ConfigureAwait(false);

            return clone;
        }

        private static async Task CloneCollectionAsync(
            ISessionImplementor session,
            DeepCloneOptions opts,
            DeepCloneParentEntity parentEntity,
            IDictionary<object, object> resolvedEntities,
            dynamic newCollection,
            object collection,
            bool cloneAsReference, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            if (!(collection is IEnumerable enumerable))
            {
                return;
            }

            var enumerableType = enumerable.GetType();
            if (enumerableType.IsAssignableToGenericType(typeof(IDictionary<,>)))
            {
                foreach (dynamic pair in enumerable)
                {
                    var clone = cloneAsReference
                        ? (object)pair.Value
                        : await (session.DeepCloneAsync((object)pair.Value, opts, null, resolvedEntities, parentEntity, cancellationToken)).ConfigureAwait(false);
                    newCollection.Add(pair.Key, (dynamic) clone);
                }
            }
            else
            {
                foreach (var item in enumerable)
                {
                    var clone = cloneAsReference
                        ? item
                        : await (session.DeepCloneAsync(item, opts, null, resolvedEntities, parentEntity, cancellationToken)).ConfigureAwait(false);
                    newCollection.Add((dynamic) clone);
                }
            }
        }

        private static Task<object> LoadEntityAsync(ISessionImplementor sessionImpl, System.Type type, object identifier, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled<object>(cancellationToken);
            }
            try
            {
                if (sessionImpl is IStatelessSession statelessSession)
                {
                    return statelessSession.GetAsync(sessionImpl.Factory.TryGetGuessEntityName(type), identifier, cancellationToken);
                }

                return sessionImpl is ISession session ? session.LoadAsync(type, identifier, cancellationToken) : Task.FromResult<object>(null);
            }
            catch (Exception ex)
            {
                return Task.FromException<object>(ex);
            }
        }
    }
}
