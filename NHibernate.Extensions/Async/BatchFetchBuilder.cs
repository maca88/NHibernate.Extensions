//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using NHibernate.Linq;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Threading;
using System.Threading.Tasks;

namespace NHibernate.Extensions
{

    public partial class BatchFetchBuilder<TEntity, TKey> : IBatchFetchBuilder<TEntity, TKey>
    {

        Task<List<TEntity>> IBatchFetchBuilder<TEntity, TKey>.ExecuteAsync(CancellationToken cancellationToken)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled<List<TEntity>>(cancellationToken);
            }
            return ExecuteAsync(q => q, cancellationToken);
        }

        protected async Task<List<T>> ExecuteAsync<T>(Func<IQueryable<TEntity>, IQueryable<T>> convertQuery, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            var parameter = KeyExpresion.Parameters[0];
            var method = BatchFetchExtension.ContainsMethodInfo.MakeGenericMethod(typeof(TKey));
            var result = new List<T>();
            var currIndex = 0;
            var itemsCount = Keys.Count;
            while (currIndex < itemsCount)
            {
                var batchNum = Math.Min(BatchSize, itemsCount - currIndex);
                var batchItems = Keys.Skip(currIndex).Take(batchNum).ToList();
                var value = Expression.Constant(batchItems, typeof(IEnumerable<TKey>));
                var containsMethod = Expression.Call(method, value, KeyExpresion.Body);
                var predicate = Expression.Lambda<Func<TEntity, bool>>(containsMethod, parameter);
                var query = Session.Query<TEntity>()
                    .Where(predicate);

                if (BeforeQueryExecutionFunction != null)
                {
                    query = BeforeQueryExecutionFunction(query);
                }

                result.AddRange(await (ToListAsync(convertQuery(query), cancellationToken)).ConfigureAwait(false));
                currIndex += batchNum;
            }

            return result;
        }
    }


    public partial class BatchFetchBuilder<TEntity, TKey, TResult> : BatchFetchBuilder<TEntity, TKey>, IBatchFetchBuilder<TEntity, TKey, TResult>
    {

        Task<List<TResult>> IBatchFetchBuilder<TEntity, TKey, TResult>.ExecuteAsync(CancellationToken cancellationToken)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return Task.FromCanceled<List<TResult>>(cancellationToken);
            }
            return ExecuteAsync(q => q.Select(SelectExpression), cancellationToken);
        }
    }
}
